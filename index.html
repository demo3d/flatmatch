<!DOCTYPE html> 

<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <meta property="og:image" content="http://rbuch703.de/osmsv/images/screenshot.png" />
    <meta property="og:description" content="See a 3D view of any position of the world directly from your web browser." />
    <meta property="og:title" content="Open Street View" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="http://rbuch703.de/osmsv/" />
    
    <meta property="fb:admins" content="100001025041261" />

    <link   type="text/css" rel="stylesheet" href="styles/global.css" media="screen" />
    <link   type="text/css" rel="stylesheet" href="styles/leaflet.css" />

    <style>
        #mapDiv { width:100%; height:400px;}
    /*
        @media (min-width: 1440px) {
              #leftNavDiv { float:left; margin-right:20px; width:400px}
              #contentDiv { margin-left: 420px; margin-right:10px; }
              #mapDiv { width:400px; height:300px }
          }

        @media (max-width: 1439px) {
              #leftNavDiv { margin-left: 10px; margin-right:50px; } //leave a 50px bar on the right to 
              #contentDiv { margin-left: 10px; margin-right:50px; } //allow for mouse and touch scrolling
              #mapDiv { width:100%; height:600px }
          }
*/
    </style>

    <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>


    <script type="text/javascript" src="leaflet.js"></script>
    <script type="text/javascript" src="tile.js"></script>
    <script type="text/javascript" src="mapLayer.js"></script>
    <script type="text/javascript" src="buildings.js"></script>
    <script type="text/javascript" src="skydome.js"></script>
    <script type="text/javascript" src="apartment.js"></script>
    <script type="text/javascript" src="controller.js"></script>
    <script type="text/javascript" src="poly2tri.js"></script>
    <script type="text/javascript" src="sun.js"></script>

	<script type="text/javascript" src="gl-matrix.js" ></script>
	<script type="text/javascript" src="glu.js" ></script>
	<script type="text/javascript" src="math.js" ></script>

    <script src="webgl-debug.js"></script>
    
	<!--<script id="map-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
            gl_FragColor = texture2D(tex, texCoordV.st);
		}
	</script> -->
    <script id="depth-shader-vs" type="x-shader/x-vertex">
	    #line 1 101
		precision mediump float;

        uniform mat4 modelViewProjectionMatrix;
		attribute vec3 vertexPosition;
        //varying vec3 worldPosition;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			//worldPosition = vertexPosition; //pass through untransformed
        }
    </script>

	<script id="depth-shader-fs" type="x-shader/x-fragment">
	    #line 1 102
		precision mediump float;
        //uniform vec3 lightPos;
        //varying vec3 worldPosition;
        
		void main(void) {
		    //vec3 lightVec = worldPosition.xyz - lightPos;
            //float depth = clamp((length(lightVec) - 4950.0)/100.0, 0.0, 1.0);
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);//vec4(vec3(depth), 1.0);
		}
	</script>


	<script id="texture-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
            gl_FragColor = texture2D(tex, texCoordV.st);
		}
	</script>

	<script id="sun-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
            gl_FragColor = vec4( 1.0, 1.0, 0.95, 1.0);
		}
	</script>



	<script id="building-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec3 texCoordV;
        varying vec3 normal;
        varying vec3 worldPosition;
        
        uniform vec3 cameraPos;
        //uniform float height;
		void main(void) {
		    const float c = 0.02;

            vec3 vView = normalize( cameraPos - worldPosition); //direction vector from surface to camera (camera is always at (0,0,0) )
            /*if (gl_FragCoord.z < 0.95)
            {
                discard;
                return;
            }*/
            float diffuse = abs( 0.5 * dot(vView, normal) );

            //gl_FragColor = vec4( (normal + 1.0)/2.0, 1.0);
            gl_FragColor = diffuse > 0.0 ? vec4( vec3(diffuse+0.3), 1.0): vec4(-diffuse+0.3, 0.0, 0.0, 1.0);
            
            if (texCoordV.z == 0.0) //HACK: z==0 --> building height was just guessed --> tint it red
                gl_FragColor = gl_FragColor * vec4(1.0, 0.9, 0.95, 1.0);

		}
	</script>

    <!-- As of version 11, Internet Explorer apparently does not support the "discard" keyword (error WEBGL11102),
         So we have to provide a shader version without it-->
	<script id="building-shader-fs-ie" type="x-shader/x-fragment">
		precision mediump float;
        varying vec3 texCoordV;
        varying vec3 normal;
        varying vec3 worldPosition;
        
        uniform vec3 cameraPos;
        //uniform float height;
		void main(void) {
		    const float c = 0.02;

            vec3 vView = normalize( cameraPos - worldPosition); //direction vector from surface to camera (camera is always at (0,0,0) )
            float diffuse = abs( 0.5 * dot(vView, normal) );

            //gl_FragColor = vec4( (normal + 1.0)/2.0, 1.0);
            gl_FragColor = diffuse > 0.0 ? vec4( vec3(diffuse+0.3), 1.0): vec4(-diffuse+0.3, 0.0, 0.0, 1.0);
            
            if (texCoordV.z == 0.0) //HACK: z==0 --> building height was just guessed --> tint it red
                gl_FragColor = gl_FragColor * vec4(1.0, 0.9, 0.95, 1.0);

		}
	</script>

	
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec2 vertexTexCoords;  			
		
		uniform mat4 modelViewProjectionMatrix;

        varying vec2 texCoordV;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			texCoordV = vertexTexCoords;
		}
	</script>

	<script id="shadowed-shader-vs" type="x-shader/x-vertex">
	    #line 1 110
		attribute vec3 vertexPosition;
        attribute vec2 vertexTexCoords;  			
        attribute vec3 normalIn;
		
		uniform mat4 modelViewProjectionMatrix;
		uniform mat4 shadowMatrix;

        varying vec2 texCoordV;
        varying vec4 shadowTexPosition;
        varying vec3 normalOut;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			shadowTexPosition = shadowMatrix * vec4(vertexPosition, 1.0);
			texCoordV = vertexTexCoords;
			normalOut = normalIn;
		}
	</script>

	<script id="shadowed-texture-shader-fs" type="x-shader/x-fragment">
	    #line 1 111
		precision mediump float;
		
		
        varying vec2 texCoordV;
        varying vec4 shadowTexPosition;
        varying vec3 normalOut;
        
        uniform sampler2D tex;
        uniform sampler2D shadowTex;    //light source depth texture
		uniform vec3 sunDir;
		void main(void) {
		    vec4 col1 = texture2D(tex, texCoordV.st);
		    //shadow position in normalized device coordinates
            vec3 shadowNDC = (shadowTexPosition.xyz / shadowTexPosition.w) * 0.5 + 0.5;
		    
		    //float sample = ;
		    /*const float near = 4900;
		    const float far  = 5100;
		    const float a    = far / (far - near);
		    const float b    = far * near / (near - far);*/
		    
		    float depth = shadowNDC.z;
		    int inLight = 0;
		    const float delta = 0.5/2048.0;
		    if (texture2D(shadowTex, vec2(shadowNDC.s,         shadowNDC.t        ) ).r + 0.00002 >= depth) inLight++;
		    /*if (texture2D(shadowTex, vec2(shadowNDC.s,         shadowNDC.t + delta) ).r + 0.00001 >= depth) inLight++;
		    if (texture2D(shadowTex, vec2(shadowNDC.s + delta, shadowNDC.t        ) ).r + 0.00001 >= depth) inLight++;
		    if (texture2D(shadowTex, vec2(shadowNDC.s + delta, shadowNDC.t + delta) ).r + 0.00001 >= depth) inLight++;*/
		    //float normDepth = a + b / 
		    
		    float sunDiff = dot(sunDir, normalOut);
            if (( sunDiff < 0.00001) || (inLight == 0))
                gl_FragColor = col1;
            else		    
    		    gl_FragColor = vec4(col1.rgb*(1.0 + float(inLight)/2.5 * sunDiff), 1.0);
		    /*if (inLight)
		        gl_FragColor = col1*1.2;
	        else
                gl_FragColor = col1;*/
		}
	</script>


	<script id="building-shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec3 vertexTexCoords; 			
        attribute vec3 vertexNormal;
		
		uniform mat4 modelViewProjectionMatrix;

        varying vec3 texCoordV;
        varying vec3 normal;
        varying vec3 worldPosition;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			worldPosition = vertexPosition; //pass through untransformed
			texCoordV = vertexTexCoords;
			normal = vertexNormal;
		}
	</script>

    <script id="edge-shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
		
		uniform mat4 modelViewProjectionMatrix;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
		}
	</script>

	<script id="edge-shader-fs" type="x-shader/x-fragment">
		precision mediump float;

		void main(void) {
		
            gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
		}
	</script>	
    
    <script type="text/javascript">
    "use strict"
  
    //pasted from controller.js; FIXME: find better common place
    function toDictionary (queryString)
    {
        var parts = queryString.split("&");
        var res = {};
        for (var i in parts)
        {
            var kv = parts[i].split("=");
            if (kv.length == 2)
            {
                res[kv[0]] = parseFloat(kv[1]);
            }
        }
        return res;
    }


    //copied from helper.js; TODO. find better shared location
    function getFloorName( level)
    {
        if (level == 0) return "Erdgeschoss";
        if (level > 0) return level + ". Etage";
        if (level < 0) return level + ". Untergeschoss";
    }

    //copied from helper.js; TODO. find better shared location
    function asPriceString( val)
    {
        var tmp = Math.floor(val * 100);
        var res = Math.floor(tmp / 100);
        tmp = tmp % 100;
        if (tmp < 10) tmp = "0" + tmp;
        return res + "," + tmp + " €";
    }


    function offerMetadataLoaded(offer)
    {
        Controller.position = {"lat": offer.lat, "lng": offer.lon};
        //educated guess (3m per level, plus 1m for basement part that is above ground
        var apartmentFloorHeight = offer.level * 3.0 + 1.0;
        Controller.localPosition.z =  apartmentFloorHeight+ 1.6; 
        layoutId = offer.layoutId;
        if (offer.yaw != null)
            Controller.viewAngleYaw = parseFloat(offer.yaw);
            
        lblAddress.innerHTML = offer.address;
        lblLevel.innerHTML = getFloorName(offer.level);
        lblSize.innerHTML = offer.area + "m²";
        lblRooms.innerHTML = offer.numRooms;
        lblRent.innerHTML = asPriceString(offer.rent);
        lblDetails.innerHTML = "<a target='_blank' href='http://www.wobau-magdeburg.de/"+ offer.detailsUrl + "'>[in neuem Tab]</a>"
        //addressLog.innerHTML = offer.address;

            
        Controller.onRequestFrameRender = scheduleFrameRendering;
        
        map = L.map('mapDiv', {keyboard:false} ).setView([offer.lat, offer.lon], 18);
        map.on("click", onMapClick);
        map.on("zoomend", renderFrustum);

        L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:0
        }).addTo(map);

        L.control.scale({imperial:false, position:"topright"}).addTo(map);
	    initGl();  //initialize webGL canvas

        /* prevention of default event handling is required for:
         * - 'mousedown': otherwise dragging the mouse cursor beyond the canvas would select the page text in chrome
         * - 'keydown': otherwise using the cursor keys for navigation would also scroll the page
         */

        if (gl)
        {
		    //register event handlers
		    webGlCanvas.addEventListener("mousedown",   function(ev) {ev.preventDefault(); Controller.onMouseDown(ev);}, false);
		    webGlCanvas.addEventListener("mouseup",     function(ev) {Controller.onMouseUp(ev);},   false);
		    webGlCanvas.addEventListener("mouseout",    function(ev) {Controller.onMouseUp(ev);},   false);
		    webGlCanvas.addEventListener("mousemove",   function(ev) {Controller.onMouseMove(ev);}, false);
            webGlCanvas.addEventListener("touchstart",  function(ev) {Controller.onTouchDown(ev);}, false);
            webGlCanvas.addEventListener("touchcancel", function(ev) {Controller.onTouchEnd(ev);},  false);
            webGlCanvas.addEventListener("touchend",    function(ev) {Controller.onTouchEnd(ev);},  false);
            webGlCanvas.addEventListener("touchleave",  function(ev) {Controller.onTouchEnd(ev);},  false);
            webGlCanvas.addEventListener("touchmove",   function(ev) {Controller.onTouchMove(ev);}, false);
        }

        document.addEventListener("keydown", function(ev) { if (ev.keyCode == 38 || ev.keyCode == 40) ev.preventDefault(); Controller.onKeyDown(ev);},  false);
        document.addEventListener("keyup",   function(ev) {Controller.onKeyUp(ev);},  false);
		document.body.onresize = onResize;

        mapApartment = new Apartment(offer.layoutId, Controller.position, offer.yaw != null ? offer.yaw : 0.0, apartmentFloorHeight);
        mapApartment.onLoaded = onApartmentLoaded;
        //onChangeLocation();
        minimapCanvas.addEventListener("click", function(ev) {onMinimapClick(ev.pageX - minimapCanvas.offsetLeft, ev.pageY - minimapCanvas.offsetTop);});
    }    
    
    function onMinimapClick(x,y)
    {
	    var canvasScale = Math.min( minimapCanvas.width / layoutImage.width, minimapCanvas.height / layoutImage.height);
        x/= canvasScale;
        y/= canvasScale;
    
        var newPos = mapApartment.pixelToLocalCoordinates([x,y]);
        Controller.localPosition.x = newPos.x;
        Controller.localPosition.y = newPos.y;
        scheduleFrameRendering();
    }
    
    function onSunPositionChanged(day, time)
    {
        //console.log("new sun position is %s/%s", day, time);
        mapSun.dayOfYear = day;
        mapSun.time = time;
        mapSun.buildGlGeometry();
        //renderDepthTexture();
        depthTextureDirty = true;
        scheduleFrameRendering();
    }
        
    function init()
    {
        var idx = document.URL.indexOf("?");
        if (idx)
        {
            var params = toDictionary (document.URL.substring(idx + 1));
            rowId = params.rowid ? parseInt(params.rowid) : 13;
                
        }

        
        $( "#slider-day" ).slider({
            min: 1,
            max: 365,
            value: 200,
            step:1,
            stop:  function() {onSunPositionChanged( $( "#slider-day" ).slider( "value"), mapSun.time); },
            slide: function( event, ui ) { onSunPositionChanged(ui.value, mapSun.time); }
            });

        $( "#slider-time" ).slider({
            min: 0,
            max: 24,
            value: 10,
            step:0.1,
            stop:  function() {onSunPositionChanged(mapSun.dayOfYear, $( "#slider-time" ).slider("value")); },
            slide: function( event, ui ) { onSunPositionChanged(mapSun.dayOfYear, ui.value); }
            });

        
        var req = new XMLHttpRequest();
        req.open("GET", OFFER_REST_BASE_URL + "/get/offer/" + rowId );
        req.responseType = "";
        req.onreadystatechange = function() 
        { 
            if (this.readyState != 4 || this.response == null)
                return;

            offerMetadataLoaded( JSON.parse(this.response) );
        }
        
        req.send();


    }   
    
    var narrowLayout;

    var map;
    var mapPlane;
    var mapBuildings;
    var mapSkyDome;
    var mapApartment;
    var mapSun;
    
    var mapFrustum;
    
    var colorTexture, depthTexture, framebuffer;
    var shadowMvpMatrix = mat4.create();
    
    var depthTextureSize = 1024*2;
    var depthTextureDirty = true;
    var gl;
    
    var positionMarker;
    var fieldOfView = 90/16*9;
    var layoutId;// = 158;
    var rowId;
    var OFFER_REST_BASE_URL = "http://rbuch703.de:1080/rest";
    //var OFFER_REST_BASE_URL = "http://localhost:1080/rest"
    
    function updatePositionMarker()
    {
        if (positionMarker)
            map.removeLayer(positionMarker);
        
        positionMarker = L.marker( Controller.getEffectivePosition() );
        positionMarker.addTo(map).bindPopup("You are here");
    }
    
    function onApartmentLoaded()
    {
        Controller.localPosition.x = mapApartment.startingPos[0];
        Controller.localPosition.y = mapApartment.startingPos[1];
        
        /*map.panTo(Controller.position);
        if (map.getZoom() < 16)
            map.setZoom(16);*/

        layoutImage = new Image();
        layoutImage.onload = function() {onResize(); renderMiniMap();};
        layoutImage.src = OFFER_REST_BASE_URL + "/get/layout/"+ layoutId;
        
        mapPlane = new MapLayer(gl, Controller.position);
        mapPlane.onProgress= scheduleFrameRendering;

        mapBuildings = new Buildings(gl, Controller.position);
        mapBuildings.onLoaded = scheduleFrameRendering;
        
        mapSun = new Sun( Controller.position.lat, Controller.position.lng );
        onSunPositionChanged( $( "#slider-day" ).slider( "value"), $( "#slider-time" ).slider( "value"));
        //renderDepthTexture();  //needs sun and apartment
        
        //window.setTimeout( animateSun, 50); 
        
        updatePositionMarker();
        //console.log("Setting map center to %o", position);
        //Controller.updateHistoryState();
        //renderFrustum();
        /* make sure the 3D view is visible when a user clicked on the map (as this is usually what the user wants
         * when he clicks on a map location. For the wide layout, the 3D view should align with the top of the screen ("true")
         * to show the whole 3D view. For the narrow layout, the 3D view is the last important part on the page and should
         * align with the bottom of the page to allow the map to be shown above. */
        
        webGlCanvas.scrollIntoView( narrowLayout ? !narrowLayout.matches : true);
        scheduleFrameRendering();
    }
    
    function onMapClick(e)
    {
        /*var dLat = e.latlng.lat - Controller.position.lat;
        var dLng = e.latlng.lng - Controller.position.lng;

        var earthCircumference = 2 * Math.PI * (6378.1 * 1000);
        var metersPerDegreeLat = earthCircumference / 360;
        var metersPerDegreeLng = metersPerDegreeLat * Math.cos( Controller.position.lat / 180 * Math.PI);
        
        var dx = dLng * metersPerDegreeLng - Controller.localPosition.x;
        var dy = dLat * metersPerDegreeLat - Controller.localPosition.y;
        var dYaw = -(Math.atan2(dy, dx) / Math.PI * 180 - 90);
        //console.log(e.latlng.lat, e.latlng.lng, dYaw);
        yawLog.innerHTML = "./setApartmentYaw.py " + rowId + " " + dYaw.toFixed(1);
        posLog.innerHTML = "./setApartmentPosition.py " + rowId + " " + e.latlng.lat + " " + e.latlng.lng;
        */
        
        /*Controller.position = e.latlng;
        onChangeLocation();*/
    }   
    
    var frameRenderingScheduled = false;
    function scheduleFrameRendering()
    {
        if (frameRenderingScheduled)
            return;

        frameRenderingScheduled = true;
        if (window.requestAnimationFrame)
            window.requestAnimationFrame(executeFrameRendering);
        else
            executeFrameRendering();
    }
    
    function executeFrameRendering()
    {
        if (Controller.keysStillPressed())
            Controller.updateKeyInteraction();

        if (Controller.position.lat === undefined || Controller.position.lng === undefined)
            return;
            
        updatePositionMarker();
        renderFrustum();
        renderScene();
        renderMiniMap();
        frameRenderingScheduled = false;
        
        // If at least one key is still pressed, schedule rendering of the next frame right away:
        // A pressed key will potentially change the scene and require a re-rendering
        if (Controller.keysStillPressed())   
            scheduleFrameRendering();
    }

    function animateSun()
    {
        mapSun.time = (mapSun.time + 0.05) % 24;
        mapSun.buildGlGeometry();
        scheduleFrameRendering();
        window.setTimeout( animateSun, 50); 
    }
	
	function renderFrustum()
	{
	    if (!gl)
	        return;
	    if (mapFrustum)
	    {
	        map.removeLayer(mapFrustum);
	        mapFrustum = null;
        }
	    
	    var effectivePosition = Controller.getEffectivePosition();
	    
	    /* One degree latitude on earth always corresponds to the same distance in meters ( 1/360th of the earth circumference).
	     * But the distance of one degree longitude changes depending of the current latitude.
	     * This aspect is the ration between the two distances. It is needed to correctly
	     * draw that viewing frustum, which needs to be specified in lat/lnt
	    */
	    var localAspect = Math.cos( effectivePosition.lat / 180 * Math.PI);
	    
        var yawRad = Controller.viewAngleYaw / 180 * Math.PI;
        /* compute only planar lookDir (ignoring pitch), as this is the relevant direction to render the frustum
           on a 2D map
         */
        var lookDir = [Math.sin( yawRad), Math.cos(yawRad)];
	    
	    //console.log ("local aspect ratio at %s is %s", position.lat, localAspect );
	    
	    //console.log( webGlCanvas.height, webGlCanvas.width, fieldOfView / webGlCanvas.height * webGlCanvas.width);
	    var phi = (0.5 * fieldOfView / webGlCanvas.height * webGlCanvas.width ) / 180 * Math.PI;
	    var leftDir = [ Math.cos(phi) * lookDir[0]  - Math.sin(phi) * lookDir[1], 
	                    Math.sin(phi) * lookDir[0]  + Math.cos(phi) * lookDir[1] ];
	    var rightDir =[ Math.cos(-phi) * lookDir[0] - Math.sin(-phi) * lookDir[1], 
	                    Math.sin(-phi) * lookDir[0] + Math.cos(-phi) * lookDir[1] ];

        var len = Math.pow(0.5, map.getZoom())*2000;
        //console.log(map.getZoom(), len);
	    var pA = { lat: effectivePosition.lat + leftDir[1]*len*localAspect,  lng: effectivePosition.lng + leftDir[0]*len };
	    var pB = { lat: effectivePosition.lat + rightDir[1]*len*localAspect, lng: effectivePosition.lng + rightDir[0]*len};
	    var line = [effectivePosition, pA, pB, effectivePosition ]
	    mapFrustum = L.polygon(line, {color: 'red', noClip: 'true', fillColor:"white", fillOpacity:0.4}).addTo(map);
	}
	
	/**
	 * Initialises WebGL and creates the 3D scene.
	 */
	function initGl()
	{
        //create context
		gl = webGlCanvas.getContext("webgl") || webGlCanvas.getContext("experimental-webgl");
		if(!gl)
		{
		    //remove controls that depend on webGL, and show error messages
	        glErrorDiv.style.display = "inherit";
	        leftNavDiv.style.display = "none";
	        gl = null;
	        contentDiv.removeChild(webGlCanvas);
			return;
		}
		glu.init();
		//gl = WebGLDebugUtils.makeDebugContext(gl);
		
		gl.clearColor(0.5, 0.5, 0.5, 1.0);

		gl.clearDepth(1.0);
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.CULL_FACE);

        onResize();
	
        mapSkyDome = new SkyDome(gl);
        mapSkyDome.onLoaded = scheduleFrameRendering;

        // Create a color texture for use with the depth shader
        colorTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, depthTextureSize, depthTextureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        // Create the depth texture
        depthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, depthTextureSize, depthTextureSize, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);

        framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	}
	

	function onResize()
	{
	    /*Note: 
	     *   - Canvas.style.height sets the size of the object on screen, but is a CSS property (may also be something like "100%")
	     *   - Canvas.height sets the logical size of the drawing buffer is pixels (its content is later scaled to fit the object on screen)
	     *   - Canvas.clientHeight is the read-only value of the consequence of Canvas.style.height in pixels (even if style.height is given in percent, etc.)
         */	    
	    webGlCanvas.style.height = webGlCanvas.clientWidth / 16 * 9 + "px";
        webGlCanvas.height = webGlCanvas.clientHeight / 2;
        webGlCanvas.width  = webGlCanvas.clientWidth / 2;


        if (layoutImage)
        {
	        var aspect = layoutImage.width / layoutImage.height;
	        minimapCanvas.style.height = minimapCanvas.clientWidth / aspect + "px";
            minimapCanvas.height = minimapCanvas.clientHeight;
            minimapCanvas.width  = minimapCanvas.clientWidth;
        }
        
        scheduleFrameRendering();
	}	
	
	var layoutImage;
	
	function renderMiniMap()
	{
	    if (!layoutImage)
	        return;

	    if (!minimapCanvas.context2d)
	        minimapCanvas.context2d = minimapCanvas.getContext("2d");

        var ctx = minimapCanvas.context2d;
        ctx.clearRect ( 0 , 0 , minimapCanvas.width , minimapCanvas.height );
	    var canvasScale = Math.min( minimapCanvas.width / layoutImage.width, minimapCanvas.height / layoutImage.height);
	    ctx.globalAlpha = 0.5;
	    ctx.drawImage(layoutImage, 0, 0, layoutImage.width * canvasScale, layoutImage.height * canvasScale);
	    ctx.globalAlpha = 1.0;
	    
	    var pos = mapApartment.localToPixelCoordinates( Controller.localPosition );
	    //console.log(pos);
	    pos[0] *= canvasScale;
	    pos[1] *= canvasScale;
        var RADIUS = minimapCanvas.width / 60;

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#44D";
        ctx.beginPath();
        ctx.arc(pos[0], pos[1], RADIUS, 0, 2 * Math.PI);
        ctx.stroke();

        var effYaw = Controller.viewAngleYaw - mapApartment.yawShift;
        effYaw = effYaw / 180 * Math.PI;
        var lookDir = [Math.sin(effYaw), Math.cos(effYaw) ];
        ctx.strokeStyle = "#D44";
        ctx.beginPath();
        ctx.moveTo( pos[0], pos[1]);
        ctx.lineTo( pos[0] + 2*RADIUS * lookDir[0], pos[1] - 2*RADIUS * lookDir[1]);
        ctx.stroke();

	}

    function renderDepthTexture()
    {
        //the sun is the camera for this render pass, so we cannot render without knowing its position
        if (!mapSun) 
            return;

        //use created texture-backed framebuffer as render target (and not the default buffer that is output to screen)
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        
        //gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
        //gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
		gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
		gl.viewport(0, 0, depthTextureSize, depthTextureSize);

        var modelViewMatrix = mat4.create();
        var pos = mapSun.getPosition();
        pos[1] = -pos[1];
        mat4.lookAt(modelViewMatrix, pos, [0, 0, Controller.localPosition.z], [0,0,1]);
    	mat4.scale(modelViewMatrix, modelViewMatrix, [1,-1,1]);//negate y coordinate to make positive y go downward
	    var projectionMatrix = mat4.create();
	    mat4.perspective(projectionMatrix, fieldOfView/180*Math.PI/300, webGlCanvas.width / webGlCanvas.height, 3000, 5100.0);

        // the apartment shader needs this later to access the shadow buffer
        shadowMvpMatrix = mat4.create();
        mat4.mul(shadowMvpMatrix, projectionMatrix, modelViewMatrix);

        gl.disable(gl.CULL_FACE);

        if (mapApartment)
            mapApartment.renderDepth(modelViewMatrix, projectionMatrix);
        
        if (mapBuildings)
            mapBuildings.renderDepth(modelViewMatrix, projectionMatrix);

    }
	
	function renderScene()
	{
	    if (!gl || !Controller.localPosition ) //not yet initialized
	        return;

        if (depthTextureDirty)
        {
            renderDepthTexture();
            depthTextureDirty = false;
        }
        
        //select default frame buffer (do not render to texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
		gl.viewport(0, 0, webGlCanvas.width, webGlCanvas.height);

        var modelViewMatrix = glu.lookAt(Controller.viewAngleYaw, Controller.viewAnglePitch, Controller.localPosition);
	    var projectionMatrix = mat4.create();
	    mat4.perspective(projectionMatrix, fieldOfView/180*Math.PI, webGlCanvas.width / webGlCanvas.height, 0.2, 5100.0);

        gl.enable(gl.CULL_FACE);

        //note: mapApartment has to be rendered last, as it clears the z-buffer to work
        //      around some artifacts. Rendering anything afterwards will likely overdraw
        //      portions of the image even though they are close to the camera
        var renderItems = [mapPlane, mapBuildings, mapSkyDome, mapSun, mapApartment];
        for (var i in renderItems)
            if (renderItems[i])
                renderItems[i].render(modelViewMatrix, projectionMatrix, shadowMvpMatrix);
		//gl.flush();
	}
	
    </script>
    <title>Open Street View</title>
</head>

<body onload="init()"> <!-- style ="padding: 0px; margin: 0px;" -->

<div id="glErrorDiv" style="display:none">
    <h2 style="">Open Street View</h2>

    <p style="font-weight:bold; color:#F00">
    Unfortunately, your browser does not support 3D web graphics ("WebGL"), which are required for this page to work.</p>
    <p>
    This page should work on desktop and laptop computers with most recent browsers (e.g. Firefox, Chrome, Internet Explorer). To date, desktop Safari browsers require <a target="_blank" href="https://discussions.apple.com/thread/3300585?start=0">some tuning</a> to support 3D web graphics.</p>
    <p>
    For mobile devices (tablets and smartphones), most recent Android-based devices (usually those with Android 4.3 and newer) should support 3D web graphics. Apple's iPhone and iPad series of devices currently does not.
    </p>
    Here's a screenshot of what you are missing:<br>
    <img src="images/screenshot.png">
</div>



<div style="width:100%; height:100%">
<div id="leftNavDiv" style="display: inline-block; width: 29%; height:100%; vertical-align:top">
    <h4> Apartment Layout: </h4>    
	<canvas id="minimapCanvas" style="width:100%; border: 1px solid black" ></canvas>

    <h4> Neighborhood </h4>
    <div id="mapDiv" > </div>

    Tag: <div id="slider-day" style="width:100%"></div>   
    Zeit: <div id="slider-time" style="width:100%"></div>   
</div>


<div id="contentDiv" style="display: inline-block; width:70%; vertical-align:top">
    <!-- <div id="nav" style="background-color:#EEE; position:fixed; width:75%; top:50px; bottom:0px; right: 0px; overflow-y:scroll">-->
		<canvas id="webGlCanvas" style="width:100%; background:black" ></canvas>
        <div style="font-size:80%; font-style:italic">
The map and building geometry are &copy;OpenStreetMap contributors and are <a href="http://www.openstreetmap.org/copyright">licensed</a> under the Creative Commons BY-SA (map) and Open Database License (buildings) licenses.<br> For administrative questions on this page please contact the <a href="mailto:rbuch703@gmail.com">webmaster</a>.
        </div>
        
        <div style="padding-left:20px; padding-top: 20px">
        <h3>Angebotsinformationen</h3>
        <table>
            <tr><td style="font-weight:bold">Anschrift:</td><td id="lblAddress"></td></tr>
            <tr><td style="font-weight:bold">Anzahl Zimmer:</td><td id="lblRooms"></td></tr>
            <tr><td style="font-weight:bold">Größe:</td><td id="lblSize"></td></tr>
            <tr><td style="font-weight:bold">Etage:</td><td id="lblLevel"></td></tr>
            <tr><td style="font-weight:bold">Kaltmiete+Nebenkosten:</td><td id="lblRent"></td></tr>
            <tr><td style="font-weight:bold">weitere Informationen</td><td id="lblDetails"></td></tr>
            
        </table>
        </div>
<!--        <span id="yawLog" style="color:#FF0000">YAW</span><br>
        <span id="posLog" style="color:#0000FF">LAT LNG</span><br><br>
        <span id="addressLog" style="color:#777">Address</span><br> -->
</div>
</div>


</body>


</html>

